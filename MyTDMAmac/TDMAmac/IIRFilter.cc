//***************************************************************************
// * File:        This file is part of TS2.
// * Created on:  07 Dov 2016
// * Author:      Yan Zong, Xuweu Dai
// *
// * Copyright:   (C) 2016 Northumbria University, UK.
// *
// *              TS2 is free software; you can redistribute it and/or modify it
// *              under the terms of the GNU General Public License as published
// *              by the Free Software Foundation; either version 3 of the
// *              License, or (at your option) any later version.
// *
// *              TS2 is distributed in the hope that it will be useful, but
// *              WITHOUT ANY WARRANTY; without even the implied warranty of
// *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// *              GNU General Public License for more details.
// *
// * Funding:     This work was financed by the Northumbria University Faculty
//                Funded and RDF funded studentship, UK
// ****************************************************************************

#include "IIRFilter.h"
#include "rt_nonfinite.h"
#include "IIR.h"
// #include "IIR_terminate.h"   /* (no terminate code required) */

#include "Nondirect.h"
#include "IIR_data.h"

Define_Module(IIRFilter);

#define NumBitsPerChar                 8U

dspcodegen_BiquadFilter Hd; // from IIR_data.c

// from rt_nonfinite.c
// *******************************************************************
//real_T rtInf;
//real_T rtMinusInf;
//real_T rtNaN;
//real32_T rtInfF;
//real32_T rtMinusInfF;
//real32_T rtNaNF;
// *******************************************************************


void IIRFilter::initialize()
{
    EV << "IIR Filter initialisation "<<endl;
    IIR_initialize();
}


/*
int IIRFilter::iirFilter(int argc, const char * const argv[])
{
    (void)argc;
    (void)argv;

    // Initialize the application.
    //   You do not need to do this more than one time.
    IIR_initialize();

    // Invoke the entry-point functions.
    //   You can call entry-point functions multiple times.
    main_IIR();

    // Terminate the application.
    //   You do not need to do this more than one time.
    // IIR_terminate();
    // (no terminate code required)

    return 0;
}
*/

/*
// Function Definitions
double IIRFilter::argInit_real_T(void)
{
  return 0.0;
}


double IIRFilter::main_IIR(void)
{
  double y;

  // Initialize function 'IIR' input arguments.
  // Call the entry-point 'IIR'.
  y = IIR(argInit_real_T());

  return y;
}
*/

// from IIR.c
double IIRFilter::mainIIR(double x)
{
  // IIR_initialize();
  /* IIR Filters input x and returns output y. */
  /*  MATLAB Code */
  /*  Generated by MATLAB(R) 8.6 and the DSP System Toolbox 9.1. */
  /*  Generated on: 07-Apr-2017 15:41:37 */
  /*  To generate C/C++ code from this function use the codegen command. */
  /*  Type 'help codegen' for more information. */
  return Nondirect_stepImpl(&Hd, x);
}

// from Nondirect.c
// *******************************************************************
double IIRFilter::Nondirect_stepImpl(dspcodegen_BiquadFilter *obj, double varargin_1)
{
  double varargout_1;
  dspcodegen_BiquadFilter *b_obj;
  double stageIn;
  b_obj = obj;

  /* System object Outputs function: dsp.BiquadFilter */
  stageIn = b_obj->cSFunObject.P3_RTP3COEFF[0U] * varargin_1;
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[0] *
    b_obj->cSFunObject.W0_FILT_STATES[0];
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[1] *
    b_obj->cSFunObject.W0_FILT_STATES[1];
  varargout_1 = b_obj->cSFunObject.P1_RTP1COEFF[0] * stageIn;
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[1] *
    b_obj->cSFunObject.W0_FILT_STATES[0];
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[2] *
    b_obj->cSFunObject.W0_FILT_STATES[1];
  b_obj->cSFunObject.W0_FILT_STATES[1] = b_obj->cSFunObject.W0_FILT_STATES[0];
  b_obj->cSFunObject.W0_FILT_STATES[0] = stageIn;
  stageIn = b_obj->cSFunObject.P3_RTP3COEFF[1U] * varargout_1;
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[2] *
    b_obj->cSFunObject.W0_FILT_STATES[2];
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[3] *
    b_obj->cSFunObject.W0_FILT_STATES[3];
  varargout_1 = b_obj->cSFunObject.P1_RTP1COEFF[3] * stageIn;
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[4] *
    b_obj->cSFunObject.W0_FILT_STATES[2];
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[5] *
    b_obj->cSFunObject.W0_FILT_STATES[3];
  b_obj->cSFunObject.W0_FILT_STATES[3] = b_obj->cSFunObject.W0_FILT_STATES[2];
  b_obj->cSFunObject.W0_FILT_STATES[2] = stageIn;
  stageIn = b_obj->cSFunObject.P3_RTP3COEFF[2U] * varargout_1;
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[4] *
    b_obj->cSFunObject.W0_FILT_STATES[4];
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[5] *
    b_obj->cSFunObject.W0_FILT_STATES[5];
  varargout_1 = b_obj->cSFunObject.P1_RTP1COEFF[6] * stageIn;
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[7] *
    b_obj->cSFunObject.W0_FILT_STATES[4];
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[8] *
    b_obj->cSFunObject.W0_FILT_STATES[5];
  b_obj->cSFunObject.W0_FILT_STATES[5] = b_obj->cSFunObject.W0_FILT_STATES[4];
  b_obj->cSFunObject.W0_FILT_STATES[4] = stageIn;
  stageIn = b_obj->cSFunObject.P3_RTP3COEFF[3U] * varargout_1;
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[6] *
    b_obj->cSFunObject.W0_FILT_STATES[6];
  stageIn -= b_obj->cSFunObject.P2_RTP2COEFF[7] *
    b_obj->cSFunObject.W0_FILT_STATES[7];
  varargout_1 = b_obj->cSFunObject.P1_RTP1COEFF[9] * stageIn;
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[10] *
    b_obj->cSFunObject.W0_FILT_STATES[6];
  varargout_1 += b_obj->cSFunObject.P1_RTP1COEFF[11] *
    b_obj->cSFunObject.W0_FILT_STATES[7];
  b_obj->cSFunObject.W0_FILT_STATES[7] = b_obj->cSFunObject.W0_FILT_STATES[6];
  b_obj->cSFunObject.W0_FILT_STATES[6] = stageIn;
  return varargout_1;
}

// from IIR_initialize.c
// *******************************************************************
void IIRFilter::IIR_initialize(void)
{
  dspcodegen_BiquadFilter *obj;
  int i;
  static const signed char iv0[12] = { 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1 };

  static const double dv0[8] = { -0.514291170370754, 0.686625731873651,
    -0.398823703021892, 0.307948412789063, -0.340340188506195, 0.116150835549945,
    -0.315316364829903, 0.0340848243993438 };

  static const double dv1[5] = { 0.293083640375724, 0.227281177441793,
    0.193952661760938, 0.17969211489236, 0.0 };

  static const boolean_T bv0[5] = { true, true, true, true, false };

  double b_obj;
  rt_InitInfAndNaN(8U);

  /*  The following code was used to design the filter coefficients: */
  /*  */
  /*  Fpass = 1;    % Passband Frequency */
  /*  Fstop = 2;    % Stopband Frequency */
  /*  Apass = 3;    % Passband Ripple (dB) */
  /*  Astop = 100;  % Stopband Attenuation (dB) */
  /*  Fs    = 5;    % Sampling Frequency */
  /*  */
  /*  h = fdesign.lowpass('fp,fst,ap,ast', Fpass, Fstop, Apass, Astop, Fs); */
  /*  */
  /*  Hd = design(h, 'butter', ... */
  /*      'MatchExactly', 'stopband', ... */
  /*      'SystemObject', true); */
  obj = &Hd;
  Hd.isInitialized = 1;

  /* System object Constructor function: dsp.BiquadFilter */
  obj->cSFunObject.P0_ICRTP = 0.0;
  for (i = 0; i < 12; i++) {
    obj->cSFunObject.P1_RTP1COEFF[i] = iv0[i];
  }

  for (i = 0; i < 8; i++) {
    obj->cSFunObject.P2_RTP2COEFF[i] = dv0[i];
  }

  for (i = 0; i < 5; i++) {
    obj->cSFunObject.P3_RTP3COEFF[i] = dv1[i];
  }

  for (i = 0; i < 5; i++) {
    obj->cSFunObject.P4_RTP_COEFF3_BOOL[i] = bv0[i];
  }

  /* System object Initialization function: dsp.BiquadFilter */
  b_obj = obj->cSFunObject.P0_ICRTP;
  for (i = 0; i < 8; i++) {
    obj->cSFunObject.W0_FILT_STATES[i] = b_obj;
  }
}


// from rt_nonfinite.c
// *******************************************************************
/* Function: rt_InitInfAndNaN ==================================================
 * Abstract:
 * Initialize the rtInf, rtMinusInf, and rtNaN needed by the
 * generated code. NaN is initialized as non-signaling. Assumes IEEE.
 */
void IIRFilter::rt_InitInfAndNaN(size_t realSize)
{
  (void) (realSize);
  rtNaN = rtGetNaN();
  rtNaNF = rtGetNaNF();
  rtInf = rtGetInf();
  rtInfF = rtGetInfF();
  rtMinusInf = rtGetMinusInf();
  rtMinusInfF = rtGetMinusInfF();
}

/* Function: rtIsInf ==================================================
 * Abstract:
 * Test if value is infinite
 */
boolean_T IIRFilter::rtIsInf(real_T value)
{
  return ((value==rtInf || value==rtMinusInf) ? 1U : 0U);
}

/* Function: rtIsInfF =================================================
 * Abstract:
 * Test if single-precision value is infinite
 */
boolean_T IIRFilter::rtIsInfF(real32_T value)
{
  return(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);
}

/* Function: rtIsNaN ==================================================
 * Abstract:
 * Test if value is not a number
 */
boolean_T IIRFilter::rtIsNaN(real_T value)
{

#if defined(_MSC_VER) && (_MSC_VER <= 1200)

  return _isnan(value)? TRUE:FALSE;

#else

  return (value!=value)? 1U:0U;

#endif

}

/* Function: rtIsNaNF =================================================
 * Abstract:
 * Test if single-precision value is not a number
 */
boolean_T IIRFilter::rtIsNaNF(real32_T value)
{

#if defined(_MSC_VER) && (_MSC_VER <= 1200)

  return _isnan((real_T)value)? true:false;

#else

  return (value!=value)? 1U:0U;

#endif

}
/* End of code generation (rt_nonfinite.c) */
// *******************************************************************







// from rtGetNaN.h
// *******************************************************************
/* Function: rtGetNaN ==================================================
 * Abstract:
 * Initialize rtNaN needed by the generated code.
 * NaN is initialized as non-signaling. Assumes IEEE.
 */
real_T IIRFilter::rtGetNaN(void)
{
  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
  real_T nan = 0.0;
  if (bitsPerReal == 32U) {
    nan = rtGetNaNF();
  } else {
    uint16_T one = 1U;
    enum {
      LittleEndian,
      BigEndian
    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;
    switch (machByteOrder) {
     case LittleEndian:
      {
        union {
          LittleEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0xFFF80000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        nan = tmpVal.fltVal;
        break;
      }

     case BigEndian:
      {
        union {
          BigEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;
        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;
        nan = tmpVal.fltVal;
        break;
      }
    }
  }

  return nan;
}

/* Function: rtGetNaNF ==================================================
 * Abstract:
 * Initialize rtNaNF needed by the generated code.
 * NaN is initialized as non-signaling. Assumes IEEE.
 */
real32_T IIRFilter::rtGetNaNF(void)
{
  IEEESingle nanF = { { 0 } };

  uint16_T one = 1U;
  enum {
    LittleEndian,
    BigEndian
  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;
  switch (machByteOrder) {
   case LittleEndian:
    {
      nanF.wordL.wordLuint = 0xFFC00000U;
      break;
    }

   case BigEndian:
    {
      nanF.wordL.wordLuint = 0x7FFFFFFFU;
      break;
    }
  }

  return nanF.wordL.wordLreal;
}

/* End of code generation (rtGetNaN.c) */
// *******************************************************************





// from rtGetInf.c
// *******************************************************************
/* Function: rtGetInf ==================================================
 * Abstract:
 * Initialize rtInf needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real_T IIRFilter::rtGetInf(void)
{
  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
  real_T inf = 0.0;
  if (bitsPerReal == 32U) {
    inf = rtGetInfF();
  } else {
    uint16_T one = 1U;
    enum {
      LittleEndian,
      BigEndian
    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;
    switch (machByteOrder) {
     case LittleEndian:
      {
        union {
          LittleEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0x7FF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        inf = tmpVal.fltVal;
        break;
      }

     case BigEndian:
      {
        union {
          BigEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0x7FF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        inf = tmpVal.fltVal;
        break;
      }
    }
  }

  return inf;
}

/* Function: rtGetInfF ==================================================
 * Abstract:
 * Initialize rtInfF needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real32_T IIRFilter::rtGetInfF(void)
{
  IEEESingle infF;
  infF.wordL.wordLuint = 0x7F800000U;
  return infF.wordL.wordLreal;
}

/* Function: rtGetMinusInf ==================================================
 * Abstract:
 * Initialize rtMinusInf needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real_T IIRFilter::rtGetMinusInf(void)
{
  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);
  real_T minf = 0.0;
  if (bitsPerReal == 32U) {
    minf = rtGetMinusInfF();
  } else {
    uint16_T one = 1U;
    enum {
      LittleEndian,
      BigEndian
    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;
    switch (machByteOrder) {
     case LittleEndian:
      {
        union {
          LittleEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0xFFF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        minf = tmpVal.fltVal;
        break;
      }

     case BigEndian:
      {
        union {
          BigEndianIEEEDouble bitVal;
          real_T fltVal;
        } tmpVal;

        tmpVal.bitVal.words.wordH = 0xFFF00000U;
        tmpVal.bitVal.words.wordL = 0x00000000U;
        minf = tmpVal.fltVal;
        break;
      }
    }
  }

  return minf;
}

/* Function: rtGetMinusInfF ==================================================
 * Abstract:
 * Initialize rtMinusInfF needed by the generated code.
 * Inf is initialized as non-signaling. Assumes IEEE.
 */
real32_T IIRFilter::rtGetMinusInfF(void)
{
  IEEESingle minfF;
  minfF.wordL.wordLuint = 0xFF800000U;
  return minfF.wordL.wordLreal;
}

/* End of code generation (rtGetInf.c) */
// *******************************************************************









