[General]
network = tsieee802154masterrelay
tkenv-image-path = ../../images;

# ned-path = ./;../../MiXiM/src/base;../../MiXiM/src/modules;../../MiXiM/examples;../../MiXiM/examples/ieee802154Narrow;
ned-path = ./

# Tempo limite di simulazione.
sim-time-limit =1000s
tsieee802154masterrelay.mnode.clock.sim_time_limit =1000 #仿真时间    [s]
tsieee802154masterrelay.relay[*].clock.sim_time_limit =1000 #仿真时间    [s]

**.cmdenv-ev-output = true
cmdenv-event-banners = true
cmdenv-module-messages = false
cmdenv-express-mode = true
  # cmdenv-runs-to-execute = 1




record-eventlog = true 
#output-vector-file = "${resultdir}/${configname}-${runnumber}.vec"

#output-vector-file = measure.vec
output-vector-file = ./myresult/${configname}-${runnumber}.vec
output-scalar-file = ./myresult/measure.sca
output-scalar-file-append=true


##########################################################
#			PTP parameters                        #
##########################################################

**.mnode.clock.offset = 0	#offset initial value	[s]
**.mnode.clock.drift = 0	#drift 	initial value	[ppm]
**.mnode.clock.sigma1 = 0  # drift noise  std
**.mnode.clock.sigma2 = 0  # offset noise  std
**.mnode.clock.sigma3 = 0  #measurement noise std
**.mnode.clock.u3= 0#1E-5       #measurement noise mean
**.mnode.clock.alpha = 1   #滑动滤波参数
**.mnode.clock.beta =1
#**.snode[*].ptpcore.node.s1 = 1E-9  # drift noise  std
#**.snode[*].ptpcore.node.s2 = 1E-7  # offset noise  std
#**.snode[*].ptpcore.node.s3 = 1E-8  #measurement noise std
**.mnode.clock.Tcamp = 1E-2   #clock updatetime
**.mnode.clock.Tsync =0.1  #10Tsync,去掉统计记录值的前10个点

#------------------------------------------------------------------------
# Parameters for slave
#------------------------------------------------------------------------
**.snode[*].clock.offset = 0E-3	#offset initial value	[s]
**.snode[*].clock.drift = 1E-5	#drift 	initial value	[ppm]
**.snode[*].clock.sigma1 = 1E-9  # drift noise  std
**.snode[*].clock.sigma2 = 1E-7  # offset noise  std
#**.snode[*].clock.sigma3 = 1E-6  #measurement noise std
**.snode[*].clock.u3= 0#1E-5       #measurement noise mean
**.snode[*].clock.alpha = 1   #滑动滤波参数
**.snode[*].clock.beta =1
#**.snode[*].ptpcore.node.s1 = 1E-9  # drift noise  std
#**.snode[*].ptpcore.node.s2 = 1E-7  # offset noise  std
#**.snode[*].ptpcore.node.s3 = 1E-8  #measurement noise std
**.snode[*].clock.Tcamp = 1E-2   #clock updatetime
**.snode[*].ptpcore.ptpslave.Tcamp = 1E-2  #t2、t3之间的处理时延（ 0，0.5*Tcamp）
**.snode[*].ptpcore.ptpslave.rate =54E6     #计算包的传输速率=包长/rate
**.snode[*].ptpcore.buffertx.rate =54E6  	#rate 		[bit/s]
**.snode[*].ptpcore.buffertx.latenza = 0   #latenza 			[s]
**.snode[*].ptpcore.bufferrx.rate =54E6	#rate 		[bit/s]
**.snode[*].ptpcore.bufferrx.latenza = 0 	#latenza 			[s]
**.snode[*].ptpcore.manager.Tciclico = 0	#Periodo messaggi ciclici[s]
**.snode[*].ptpcore.manager.Byte = 48  	#Durata in byte dei pacchetti 	[Byte]
**.snode[*].ptpcore.manager.Number = 1	#numero di pacchetti di un burst
#**.snode[*].ptpcore.node.Tsync = 10#		#DEVE ESSERE UGUALE A test.Tsync
#**.snode[*].ptpcore.node.nsync = 10#


##########################################################
#			Parameters for Relay                        #
##########################################################

**.relay[*].clock.offset = 0E-3	#offset initial value	[s]
**.relay[*].clock.drift = 1E-5	#drift 	initial value	[ppm]
**.relay[*].clock.sigma1 = 1E-9  # drift noise  std
**.relay[*].clock.sigma2 = 1E-7  # offset noise  std
**.relay[*].clock.sigma3 = 1E-6  #measurement noise std
**.relay[*].clock.u3= 0#1E-5       #measurement noise mean
**.relay[*].clock.alpha = 1   #滑动滤波参数
**.relay[*].clock.beta =1
#**.snode[*].ptpcore.node.s1 = 1E-9  # drift noise  std
#**.snode[*].ptpcore.node.s2 = 1E-7  # offset noise  std
#**.snode[*].ptpcore.node.s3 = 1E-8  #measurement noise std
**.relay[*].clock.Tcamp = 1E-2   #clock updatetime
**.relay[*].core.RelaySlave.Tcamp = 1E-2  #t2、t3之间的处理时延（ 0，0.5*Tcamp）
**.relay[*].core.RelaySlave.rate =54E6     #计算包的传输速率=包长/rate
**.relay[*].core.RelayBuffer.rate =54E6  	#rate 		[bit/s]
**.relay[*].core.RelayBuffer.latenza = 0   #latenza 			[s]
#          **.snode[*].ptpcore.bufferrx.rate =54E6	#rate 		[bit/s]
#          **.snode[*].ptpcore.bufferrx.latenza = 0 	#latenza 			[s]
**.relay[*].core.manager.Tciclico = 0	#Periodo messaggi ciclici[s]
**.relay[*].core.manager.Byte = 48  	#Durata in byte dei pacchetti 	[Byte]
**.relay[*].core.manager.Number = 1	#numero di pacchetti di un burst
#**.snode[*].ptpcore.node.Tsync = 10#		#DEVE ESSERE UGUALE A test.Tsync
#**.snode[*].ptpcore.node.nsync = 10#


**.relay[*].clock.Tsync =0.1  #10Tsync,去掉统计记录值的前10个点

**.relay[*].core.RelayMaster.RandomValue = 0.1



#------------------------------------------------------------------------
# Parametri del master
#------------------------------------------------------------------------
**.mnode*.core.Tsync=0.1        # 同步周期
**.snode[*].clock.Tsync =0.1  #10Tsync,去掉统计记录值的前10个点
#**.snode[*].ptpcore.node.Tsync = 0.1  #判断t2、t3件延时的标准
#-----------**.snode[*].ptpcore.-----------------------------------------------
# Parametro dello switch
#------------------------------------------------------------------------
#TimeSyn.switch.buffer.rate = 10E6#	#rate    	[bit/s]
#TimeSyn.switch.buffer.latenza = 0#		#latenza 	[s]

#------------------------------------------------------------------------
# Parametri della sorgente
#------------------------------------------------------------------------
#TimeSyn.source.wlen = 1500#
#TimeSyn.source.T = 2E-3#
#TimeSyn.source.d = 0.3#
#TimeSyn.source.m1 = 1.7#
#TimeSyn.source.m2 = 1.7#

num-rngs = 2
**.rng-0 = 0
**.rng-1 = 1
#**.rng-2 = 2
repeat =20
seed-0-mt =100 #${runnumber}
#seed-2-mt = ${runnumber}
seed-1-mt = 9  # let RNG 1's seed is always 9




##########################################################
#			Simulation parameters                        #
##########################################################
tkenv-default-config = 
*.**.coreDebug = false
*.**.debug = false
*.playgroundSizeX = 200m
*.playgroundSizeY = 200m
*.playgroundSizeZ = 0m
*.numHosts = 2
*.numSlave = 0
*.numMaster = 1
*.numRelay = 1


##########################################################
#			WorldUtility parameters                      #
##########################################################
*.world.useTorus = false

##########################################################
#			         channel parameters                  #
##########################################################
*.connectionManager.sendDirect = false
*.connectionManager.pMax = 1.1mW
*.connectionManager.sat = -100dBm
*.connectionManager.alpha = 2.5
*.connectionManager.carrierFrequency = 2.4E+9Hz

################ PhyLayer parameters #####################
**.nic.phy.usePropagationDelay = false
 
**.nic.phy.analogueModels = xmldoc("config.xml")
**.nic.phy.sensitivity = -100dBm
**.nic.phy.maxTXPower = 1.1mW
**.nic.phy.initialRadioState = 0
**.nic.phy.useThermalNoise = true


################ MAC layer parameters ####################
**.nic.mac.notAffectedByHostState = true

################ NETW layer parameters ####################

################ ArpHost module parameters ####################
# Fpr simplicity, keep the address of all the layers the SAME
*.mnode*.arp.offset = 1000
*.mnode*.core.masterAddrOffset = 1000


*.snode*.arp.offset = 20
*.snode*.ptpcore.ptpslave.slaveAddrOffset=20

*.relay[*].arp.offset = 2000
*.relay[*].core.RelayMaster.masterAddrOffset=2000
*.relay[*].core.RelaySlave.slaveAddrOffset=2000


################ Mobility parameters #####################
**.mobilityType = "ConstSpeedMobility"

**.mobility.initFromDisplayString = false
**.mobility.initialZ = 0m

*.mnode*.mobility.initialX = 10m
*.mnode*.mobility.initialY = 10m

*.snode[0].mobility.initialX = 100m
*.snode[0].mobility.initialY = 100m

*.?node[2].mobility.initialX = 200m
*.?node[2].mobility.initialY = 100m

*.?node[*].mobility.speed = 0
*.mnode*.mobility.speed = 0

*.relay[0].mobility.initialX = 20m
*.relay[0].mobility.initialY = 20m

*.relay[1].mobility.initialX = 120m
*.relay[1].mobility.initialY = 120m

*.relay[*].mobility.speed = 0


**.**.netwl.headerLength = 16bit

**.appl.burstSize = 2
**.appl.headerLength = 128bit

*.world.bitrate = 250000

**.battery.nominal = 99999mAh
**.battery.capacity = 99999mAh
**.battery.voltage = 3.3V
**.battery.resolution = 0.1s
**.battery.publishDelta = 1
**.battery.publishTime = 0
**.battery.numDevices = 1

**.batteryStats.detail = false
**.batteryStats.timeSeries = false



[Config sigma3Runs] 
# measurement noise
description="Timestamping uncertainty of the slave clock"
#repeat =20   
#num-rngs = 3
#**.rng-0 = 0
#**.rng-1 = 1
#**.rng-2 = 2
#seed-0-mt = ${runnumber} 
#seed-0-mt = ${0,1,2,3,4,5,6,7,8,9} 
#seed-1-mt = 9  # let RNG 1's seed is always 9
#seed-2-mt = ${runnumber}
**.snode[*].clock.sigma3 =${2E-8,4E-8,6E-8,8E-8,1E-7,2E-7,4E-7,6E-7,8E-7,1E-6,2E-6,4E-6,6E-6,8E-6,\
                               1E-5,2E-5,4E-5,6E-5,8E-5,1E-4,2E-4,4E-4,6E-4,8E-4,1E-3,2E-3,4E-3,6E-3,8E-3,1E-2}
#TimeSyn.slave.node.s3 =  ${sigm3=1E-7,2E-7,4E-7,6E-7,8E-7,1E-6,2E-6,4E-6,6E-6,8E-6,\
 #                               1E-5,2E-5,4E-5,6E-5,8E-5,1E-4,2E-4,4E-4,6E-4,8E-4,1E-3}
#1E-8),sqrt(2)*(1E-6)
#{1E-8,2E-8,4E-8,6E-8,8E-8,1E-7,2E-7,4E-7,6E-7,8E-7,1E-6,2E-6,4E-6,6E-6,8E-6,\
                              # 1E-5,2E-5,4E-5,6E-5,8E-5,1E-4,2E-4,4E-4,6E-4,8E-4,1E-3,2E-3,4E-3,6E-3,8E-3,1E-2}
#${1E-7,1E-6,1E-5,1E-4,1E-3}












#################################################
# Test 1a
# this wireless sensor network of this test consists 
# of two node, namely, one master and one relay node.
# There is no packet loss (i.e., the distance between 
# two nodes, and power of the signal is good), no 
# other traffic in the transmission
##################################################
[Config Test-1a]
description = "Master and Relay, No packet Loss and No Traffic"
# *.playgroundSizeX = 10m
# *.playgroundSizeY = 10m
# *.numHosts = ${2..40 step 2}
# *.node[*].mobility.initialX = uniform(0m, 10m)
# *.node[*].mobility.initialY = uniform(0m, 10m)
# *.node[*].mobility.initialZ = uniform(0m, 10m)

*.snode[*].mobility.speed = 10mps

**.netwl.packetsPerPacketTime = 0.1


# initial position
*.mnode.mobility.initialX = 50m
*.mnode.mobility.initialY = 50m

*.relay[0].mobility.initialX = 100m
*.relay[0].mobility.initialY = 50m

# mobility speed 
*.mnode.mobility.speed = 0
*.relay[0].mobility.speed = 0















#################################################
# Test 1
# these tests produce the usage statistics of the channel
# for different configurations. Usage statistics means
# how much of the channels possible maximum capacity is
# used at which amount of generated traffic.
# 
# The results of this tests are visualized by "Test1.anf"
# and show plots of the generated traffic against the received
# traffic where both values are normalized against bitrate
# and simulation time.
##################################################
[Config Test1-A]
description = "increasing number of hosts, unbursted, with queue"
# *.playgroundSizeX = 10m
# *.playgroundSizeY = 10m
# *.numHosts = ${2..40 step 2}
# *.node[*].mobility.initialX = uniform(0m, 10m)
# *.node[*].mobility.initialY = uniform(0m, 10m)
# *.node[*].mobility.initialZ = uniform(0m, 10m)
*.mnode*.mobility.speed = 0
*.snode[*].mobility.speed = 10mps

**.netwl.packetsPerPacketTime = 0.1





[Config Test1-B]
description = "increasing send rate per host, unbursted, with queue"
*.playgroundSizeX = 10m
*.playgroundSizeY = 10m
*.numHosts = 10
*.?node[*].mobility.initialX = uniform(0m, 10m)
*.?node[*].mobility.initialY = uniform(0m, 10m)
*.?node[*].mobility.initialZ = uniform(0m, 10m)
*.?node[*].mobility.speed = 0
**.netwl.packetsPerPacketTime = ${0.02..0.4 step 0.02}
**.netwl.burstSize = 1
**.mac.queueLength = 100

[Config Test1-C]
extends = Test1-B
description = "increasing send rate per host, bursted, with queue"
**.netwl.burstSize = 3

[Config Test1-D]
extends = Test1-C
description = "increasing send rate per host, bursted, without queue"
**.mac.queueLength = 0

[Config Test1-E]
extends = Test1-B
description = "increasing send rate per host, unbursted, without queue"
**.mac.queueLength = 0


##################################################
# Test 2
# These test configurations are meant to show the effect
# of MAC-ACKS on the usage of the channel with increasing
# distance between the hosts.
# Test2-C further shows the effect of the hidden station
# problem on CSMA.
#
# The results can be visualized by "Test2.anf" and show
# plots of channel usage at different distances.
##################################################
[Config Test2-A]
description = "one sending host moving towards sink, with mac-acks"
sim-time-limit = 300s
#record-eventlog = true
*.playgroundSizeX = 500m
*.playgroundSizeY = 500m
*.numHosts = 2
*.?node[0].mobility.initialX = 350m
*.?node[0].mobility.initialY = 250m
*.?node[1].mobility.initialX = 350m - ${dist=110..300 step 5}m #${dist=40..160 step 40, 180..220 step 2, 230,240}m
*.?node[1].mobility.initialY = 250m
*.?node[*].mobility.speed = 0

*.?node[0].netwl.burstSize = 0
*.?node[1].netwl.burstSize = 1
*.?node[1].netwl.destination = 0
#*.node[1].nic.phy.coreDebug = true
**.netwl.packetsPerPacketTime = 0.25

*.world.bcTraffic = false

[Config Test2-B]
extends = Test2-A
description = "one sending host moving towards sink, without mac-acks"
*.?node[1].netwl.destination = 0
*.?node[*].nic.mac.useMACAcks = false
*.world.bcTraffic = false

[Config Test2-C]
extends = Test2-A
description = "one sending host stationary in range of sink (hidden station), \
			   one host moving towards sink and stationary sender,\
			   with mac ACKS"
*.numHosts = 3
**.netwl.packetsPerPacketTime = 0.125
*.?node[2].mobility.initialX = 480m
*.?node[2].mobility.initialY = 250m
*.?node[2].netwl.burstSize = 1
*.?node[2].netwl.destination = 0
*.?node[1].netwl.destination = 0

######################################################
# Test 3
# This tests is meant to show that CSMA uses exponential backoffs.
# This is done by increasing the number of hosts in the network exponentially.
# While the average backoff duration of each hosts should increase
# exponentially, the average number of backoffs should increase linearly.
#
# The results of this tests are visualized by "Test3.anf".
######################################################
[Config Test3]
description = "quadratic increasing number of hosts results in linear increase of backoffs"
sim-time-limit = ${numHosts}s
*.playgroundSizeX = 10m
*.playgroundSizeY = 10m
*.numHosts = ${numHosts=2,4,8,16,32,64,128,256}
*.?node[*].mobility.initialX = uniform(0m, 10m)
*.?node[*].mobility.initialY = uniform(0m, 10m)
*.?node[*].mobility.initialZ = uniform(0m, 10m)
*.?node[*].mobility.speed = 0
**.netwl.packetsPerPacketTime = 1/${numHosts}
*.?node[*].nic.mac.macMinBE = 1
*.?node[*].nic.mac.macMaxBE = 8
*.?node[*].nic.mac.macMaxCSMABackoffs = 20
*.?node[*].nic.mac.aUnitBackoffPeriod = 0.1s
*.connectionManager.sendDirect = true
**.netwl.burstSize = 2
